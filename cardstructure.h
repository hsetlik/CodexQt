#ifndef CARDSTRUCTURE_H
#define CARDSTRUCTURE_H

#include "datastructures.h"
#include <QtWidgets>
/*
 * TODO LIST updated 8/29:
 * -Add comparison for text entry cards (cloze and full)
 * -Improve layout of card views
 * -Add answer history/difficulty system to the card data structure
 */
enum class CardType
{
    NTA,
    Cloze,
    Audio,
    Full
};
struct Card
{
    Card(PhrasePair* pair, CardType type) :
        cardType(type),
        timesAnswered(0),
        lastAnswer(0)
    {
        dateNextDue = QDateTime::currentDateTime();
        parentPairId = pair->getJsonIdString().c_str();
    }
    Card(QJsonObject& obj) : cardType(getCardType(obj))
    {
        auto dateString = obj["DateNextDue"].toString();
        dateNextDue = QDateTime::fromString(dateString);
        parentPairId = obj["ParentPairId"].toString();
        timesAnswered = obj["TimesAnswered"].toInt();
        lastAnswer = obj["LastAnswer"].toInt();
    }
    static CardType getCardType(QJsonObject& obj)
    {
        auto typeString = obj["CardType"].toString().toStdString();
        if(typeString == "NTA")
            return CardType::NTA;
        else if(typeString == "Cloze")
            return CardType::Cloze;
        else
            return CardType::Full;
    }
    virtual ~Card() {}
    const CardType cardType;
    //virtual functions to be generated by the card subclasses
    //not pure virtual bc I need to be able to have template containers of type 'Card' but these are junk return values
    virtual std::string getFrontData() {return "null"; }
    virtual std::string getBackData() {return "null"; }
    //gives JSON object
    virtual QJsonObject getJson()
    {
        QJsonObject obj
        {
            {"Null", 0}
        };
        return obj;
    }
    void updateWithAnswer(int answer)
    {
        lastAnswer = answer;
        ++timesAnswered;
    }
    void setDueIn(int numDays)
    {
        dateNextDue = dateNextDue.addDays(numDays);
    }
    bool isDue(QDateTime current)
    {
        return current >= dateNextDue;
    }
protected:
    QDateTime dateNextDue;
    QString parentPairId;
    int timesAnswered;
    int lastAnswer;
};
//=================================================================================
struct NtaCard : public Card
{
public:
    NtaCard(std::string native, std::string target, PhrasePair* parent);
    NtaCard(QJsonObject& obj);
    std::string getFrontData() override {return nativeWord; }
    std::string getBackData() override {return targetWord; }
    QJsonObject getJson() override;
private:
    std::string nativeWord;
    std::string targetWord;
};
//=================================================================================
struct ClozeCard : public Card
{
public:
    ClozeCard(std::string toRemove, PhrasePair* parent);
    ClozeCard(QJsonObject& obj);
    std::string getFrontData() override {return clozeSentence; }
    std::string getBackData() override {return answer; }
    QJsonObject getJson() override;
    std::string getFullTarget(){return fullTarget; }
    std::string getFullNative(){return fullNative; }
private:
    std::string clozeSentence;
    std::string answer;
    std::string fullTarget;
    std::string fullNative;
};
//=================================================================================
struct FullCard : public Card
{
public:
    FullCard(PhrasePair* parent);
    FullCard(QJsonObject& obj);
    std::string getFrontData() override {return fullNative; }
    std::string getBackData() override {return fullTarget; }
    QJsonObject getJson() override;
private:
    std::string fullNative;
    std::string fullTarget;
};
//=================================================================================
struct PhrasePairCards
{
    PhrasePairCards(PhrasePair* parent);
    PhrasePairCards(QJsonObject& obj);
    //store all the cards as unique_ptrs and only instantiate card subclasses inside the PhrasePairCards class
    //Outside of this class, all access to and manipulation of card objects should be done via pointer to object of this class
    std::vector<std::unique_ptr<NtaCard>> ntaCards;
    std::vector<std::unique_ptr<ClozeCard>> clozeCards;
    std::unique_ptr<FullCard> full;
    QJsonObject getPairJson();
    void addAllToVector(std::vector<Card*>& allCards);
private:
    //adds all the cards to an external array for storing a deck of multiple phrase pairs
    void appendToDeckArray(QJsonArray& array);
    QJsonArray getNtaJsons();
    QJsonArray getClozeJsons();
    std::string pairId;
    std::string fullNative;
    std::string fullTarget;
};
//================================================================================
//Full deck data structure, includes functionality for storing as file JSON
class Deck
{
public:
    Deck(std::string name = "default_deck");
    ~Deck();
    void addPhrasePairFrom(QJsonObject obj);
    std::vector<PhrasePairCards> phrasePairs;
    std::vector<Card*> allCards;
    std::vector<Card*> dueToday();
    int numDueToday();
    void addNewPairs(QJsonArray newPairs);
    void saveToFile();
    std::string getName() {return deckName; }
    void pushBackDueDates(int numDays);
private:
    std::string deckName;
    QJsonObject getDeckAsObject();
    QJsonArray getPairJsons();

};
#endif // CARDSTRUCTURE_H
